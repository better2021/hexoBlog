---
title: js中事件循环eventLoop的理解
date: 2019-04-01 15:40
tags:
---

### javascript异步、事件循环、队列

![事件循环与队列](https://i.loli.net/2019/04/01/5ca1cea47230f.png)

> `堆`：存放对象、数据，垃圾回收就是检查这里
> `栈`：js主线程的函数执行，都是压到栈中进行的

> runtime:程序的运行环境，比如：浏览器环境、node.js环境。不用的runtime会提供不同的接口，
> 比如，在node.js环境中，我们可以通过`require`来引入模块，而在浏览器中，我们用ES6的`import`来引入模块

***js引擎是单线程的，通过Event Loop的机制，按顺序把任务放入栈中执行。***
 
> 异步处理模块有：定时器（settimeOut,setInterval)，网络请求，Promise，I/O操作，UI渲染等
> 异步函数达到触发条件，比如定时器到时，Ajax请求返回，那么把相应的回调处理，根据异步模块类型，压入指定的任务队列

从规范上来讲，`setTimeout`有一个4ms的最短时间，也就是说不管你设定多少，反正最少都要间隔4ms才运行里面的回调。而`Promise`的异步没有这个问题
从具体实现上来说，这俩的异步队列不一样，`Promise`所在的那个异步队列优先级要高一些
`Promise`的任务会在当前事件循环末尾中执行，而`setTimeout`中的任务是在下一次事件循环执行

### 执行上下文
- 全局执行上下文
  解析js的时候，创建一个**全局执行上下文**环境，把代码中即将执行的变量、函数声明都拿出来。**未赋值的变量就是`undefined`**

> 下面代码输出：`undefined`; 而不是抛出`Error`，因为在解析js的时候，变量 a 已经存入了全局执行上下文中了
```js
console.log(a) // undefined
var a = 1
```

- 函数执行上下文
  与全局执行上下文差不多，但是多了`this`和`argments`和参数  
  在js中，`this`是关键字，它作为内置变量，**其值是执行的时候确定的**

### js中闭包的理解
> MDN解释：闭包是**函数**和**声明该函数的词法环境**的组合
> 其他解释：闭包是一个能够访问其他函数作用域的函数
> 只要在一个函数中再定义一个函数，这个内部函数就是一个闭包。
> 闭包之所以能访问其外层函数作用域中的变量，是因为闭包的作用域链中存在外层函数的变量对象。即使外层函数之行结束，但由于其变量对象仍然被内层函数的作用域引用，因此不会被内存回收，直到闭包执行结束后，外层函数的变量对象才会被回收。
>闭包的特点闭包访问外层函数变量的特点

闭包的缺点是在IE浏览器可能会导致内存泄漏（js无法回收内存）
> 闭包封住了变量作用域，有效地防止了全局污染，但同时，它也存在`内存泄漏`的风险

解决办法前言已经提到过，把element.id 的一个副本保存在一个变量中，
从而消除闭包中该变量的循环引用同时将element变量设为null。

```js
function assignHandler(){
    var element = document.getElementById("someElement");
    var id = element.id;
    element.onclick = function(){
        alert(id);
    };
    element = null; // 释放内存
}
```
